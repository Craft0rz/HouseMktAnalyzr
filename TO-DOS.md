# TO-DOS

## Add Editable Interest Rate and Down Payment - 2026-02-10 20:15

- **Add user-configurable interest rate and down payment to PropertyDetail** - Allow users to adjust interest rate and down payment percentage directly in the property detail panel instead of using hardcoded 5% / 20% defaults. **Problem:** The Mortgage Estimate and Cash Flow cards in PropertyDetail hardcode `downPaymentPct = 0.20` and `interestRate = 0.05` (line 269-273). Users can't explore "what if" scenarios without navigating to the separate Calculator page. The backend API already accepts these as parameters. **Files:** `frontend/src/components/PropertyDetail.tsx:269-279` (hardcoded constants → state variables with inline inputs), `frontend/src/components/PropertyDetail.tsx:609-640` (Mortgage Estimate card — add input controls here), `frontend/src/app/calculator/page.tsx:14-28` (existing editable pattern to replicate). **Solution:** Replace the hardcoded `downPaymentPct` and `interestRate` with `useState` hooks initialized to 0.20 / 0.05. Add two small number inputs (or sliders) inside the Mortgage Estimate card header or above the grid. All downstream values (downPayment, principal, monthlyMortgage, netCashFlow) already derive from these — they'll recompute automatically on change. No backend changes needed since the calculation is client-side.

## Fix Safety & Development for Non-Montreal Cities - 2026-02-10 20:15

- **Fix neighbourhood data lookup returning wrong borough for cities outside Montreal** - Properties in Longueuil, Quebec City, Sherbrooke, etc. incorrectly display Montreal borough data (e.g., Longueuil shows Ahuntsic-Cartierville stats). **Problem:** The frontend sends raw `listing.city` as the borough name (line 233: `property.listing.city || 'Montreal'`). The backend `get_neighbourhood_stats_for_borough()` does an exact match first, and when that fails (Longueuil is not a Montreal borough), it falls back to a dangerous `LIKE '%longueuil%'` partial match (db.py line 1282) which returns the first random Montreal borough match. The `resolve_borough()` function in `geo_mapping.py` exists to handle this correctly but is never called in the market API flow. **Files:** `frontend/src/components/PropertyDetail.tsx:232-237` (sends raw city, no postal code), `backend/app/routers/market.py:608-738` (neighbourhood endpoint — doesn't call `resolve_borough()`), `backend/app/db.py:1264-1288` (dangerous LIKE fallback), `backend/app/geo_mapping.py:230-259` (`resolve_borough()` — exists but unused in this flow). **Solution:** (1) Pass postal code from frontend alongside city. (2) Call `resolve_borough(city, postal_code)` in the market.py endpoint before querying DB. (3) Remove or tighten the LIKE fallback in db.py to prevent false matches. (4) Return null/empty when no valid borough match exists instead of wrong data.


