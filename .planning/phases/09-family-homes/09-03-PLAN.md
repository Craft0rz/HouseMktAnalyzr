---
phase: 09-family-homes
type: execute
---

<objective>
Integrate Quebec government geo data sources to enrich the family home score with school proximity, flood zone detection, and park/playground proximity.

Purpose: The family scorer from 09-01 has placeholder hooks for geo data (school_proximity_pts, parks_pts, flood_zone). This plan connects to real Quebec open data APIs to fill those gaps, making the family score data-driven rather than based on generic metrics alone.
Output: Geo data fetchers for schools, flood zones, and parks. Integration into the family scoring pipeline.
</objective>

<execution_context>
@~/.claude/skills/create-plans/workflows/execute-phase.md
@~/.claude/skills/create-plans/templates/summary.md
</execution_context>

<context>
@.planning/BRIEF.md
@.planning/ROADMAP.md
@.planning/phases/09-family-homes/09-01-SUMMARY.md
@.planning/phases/09-family-homes/09-02-SUMMARY.md
@src/housemktanalyzr/analysis/family_scorer.py
@backend/app/routers/analysis.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Quebec geo data fetcher module</name>
  <files>src/housemktanalyzr/enrichment/quebec_geo.py</files>
  <action>
Create a new module for fetching Quebec government geo data. All functions accept latitude/longitude coordinates and return structured data.

**1. School Proximity** — Uses Donnees Quebec WFS endpoint:
- Endpoint: `https://infogeo.education.gouv.qc.ca/arcgis/rest/services/Carte_des_etablissements/MapServer/0/query`
- Parameters: `geometry={lon},{lat}&geometryType=esriGeometryPoint&spatialRel=esriSpatialRelIntersects&outFields=*&distance=2000&units=esriSRUnit_Meter&returnGeometry=true&f=json`
- Parse response for school names, types (elementary/secondary), and calculate distance using haversine formula
- Return: `list[dict]` with `name`, `type` (elementary/secondary), `distance_m`, `language` (french/english)
- Function: `async def fetch_nearby_schools(lat: float, lon: float, radius_m: int = 2000) -> list[dict]`

**2. Flood Zone Check** — Uses CEHQ ESRI REST API:
- Endpoint: `https://servicesgeo.enviroweb.gouv.qc.ca/arcgis/rest/services/CEHQ/ZonesInondables/MapServer/0/query`
- Parameters: `geometry={lon},{lat}&geometryType=esriGeometryPoint&spatialRel=esriSpatialRelIntersects&outFields=*&f=json`
- If features array is non-empty → property is in flood zone
- Return: `dict` with `in_flood_zone: bool`, `zone_type: str | None` (e.g., "Zone de grand courant", "Zone de faible courant")
- Function: `async def check_flood_zone(lat: float, lon: float) -> dict`

**3. Parks & Playgrounds** — Uses Montreal open data (GeoJSON):
- For Montreal: `https://donnees.montreal.ca/api/3/action/datastore_search` with resource for parks
- For non-Montreal: fall back to OpenStreetMap Overpass API query for `leisure=park` or `leisure=playground`
- Count parks/playgrounds within 1km radius
- Function: `async def fetch_nearby_parks(lat: float, lon: float, radius_m: int = 1000) -> dict`
- Return: `dict` with `park_count: int`, `playground_count: int`, `nearest_park_m: float | None`

**Important implementation notes:**
- Use `httpx.AsyncClient` (already a project dependency) for all HTTP requests
- Add 5-second timeout on all external API calls
- Cache results in-memory using a simple dict keyed by `(round(lat,3), round(lon,3))` to avoid repeated calls for nearby properties
- If any API call fails, return None/default gracefully — never let geo enrichment crash the scoring
- Log warnings on failures but don't raise exceptions

**Haversine helper:**
```python
import math
def haversine_distance(lat1, lon1, lat2, lon2) -> float:
    """Distance in meters between two coordinates."""
    R = 6371000
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = math.radians(lat2 - lat1)
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2
    return R * 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
```
  </action>
  <verify>python -c "import ast; ast.parse(open('src/housemktanalyzr/enrichment/quebec_geo.py').read())"</verify>
  <done>Module has 3 async functions, uses httpx, has in-memory cache, handles errors gracefully</done>
</task>

<task type="auto">
  <name>Task 2: Integrate geo data into family scoring pipeline</name>
  <files>backend/app/routers/analysis.py, src/housemktanalyzr/analysis/family_scorer.py</files>
  <action>
Update the family scoring API endpoints to fetch geo data before scoring.

**In analysis.py:**
1. In the `family-score` endpoint: after getting the listing, if latitude/longitude are available:
   - Call `fetch_nearby_schools()`, `check_flood_zone()`, `fetch_nearby_parks()` in parallel using `asyncio.gather()`
   - Extract: nearest elementary school distance, flood zone boolean, park count within 1km
   - Pass these to `FamilyHomeScorer.score_property()` via the existing parameters

2. In the `family-score-batch` endpoint:
   - For each listing with coordinates, batch the geo queries
   - Use `asyncio.gather()` to parallelize across listings (but limit concurrency to avoid hammering APIs)
   - Use `asyncio.Semaphore(10)` to limit to 10 concurrent geo API calls

**In family_scorer.py:**
Update `score_property()` to actually use the geo data parameters that were already placeholder:

School Proximity scoring (0-10 pts):
- Find the nearest elementary school from the schools list
- distance <= 500m → 10, <= 1000m → 7, <= 1500m → 4, <= 2000m → 2, > 2000m or no data → 0

Parks scoring (0-6 pts):
- park_count_1km >= 3 → 6, >= 2 → 4, >= 1 → 2, 0 → 0

Flood zone: set the `flood_zone` field on FamilyHomeMetrics (boolean flag, no score impact — it's a risk disclosure, not a penalty in the score).

Contaminated site: set field if data available (no score impact).
  </action>
  <verify>python -c "import ast; ast.parse(open('backend/app/routers/analysis.py').read())" && python -c "import ast; ast.parse(open('src/housemktanalyzr/analysis/family_scorer.py').read())"</verify>
  <done>Geo data flows from API calls through to FamilyHomeMetrics fields, school/park scores are computed, flood zone flag is set</done>
</task>

<task type="auto">
  <name>Task 3: Add geo enrichment to scraper worker for houses</name>
  <files>backend/app/scraper_worker.py</files>
  <action>
Add a new enrichment phase to the existing scraper worker that enriches HOUSE listings with geo data during the background scrape cycle.

In the scraper worker's enrichment pipeline (after walk_score, photos, conditions phases):
1. Add a new phase: `geo_enrichment`
2. Query DB for HOUSE listings that have latitude/longitude but no geo enrichment data yet
3. For each listing (up to 50 per cycle, with 1-second delay between API calls to be respectful):
   - Call `fetch_nearby_schools()`, `check_flood_zone()`, `fetch_nearby_parks()`
   - Store results in the listing's `raw_data` JSON under a `geo_enrichment` key:
     ```json
     {
       "geo_enrichment": {
         "schools": [...],
         "nearest_elementary_m": 450,
         "flood_zone": false,
         "flood_zone_type": null,
         "park_count_1km": 3,
         "nearest_park_m": 200,
         "enriched_at": "2026-02-11T..."
       }
     }
     ```
   - Update the listing's data column in the DB

4. When the family scoring endpoint receives a listing that already has geo_enrichment in raw_data, skip the live API calls and use the cached data instead

This ensures geo data is pre-fetched and family scoring is fast (no live API calls needed for enriched listings).

Important: Do NOT slow down the main scrape cycle. Add geo enrichment as a separate phase that runs AFTER all other enrichment is complete, similar to how walk_score enrichment works.
  </action>
  <verify>python -c "import ast; ast.parse(open('backend/app/scraper_worker.py').read())"</verify>
  <done>Geo enrichment phase added to scraper worker, processes up to 50 houses per cycle, stores results in DB</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "import ast; ast.parse(open('src/housemktanalyzr/enrichment/quebec_geo.py').read())"` passes
- [ ] All three geo functions handle API failures gracefully (return None/defaults)
- [ ] Family scoring endpoints use geo data when coordinates are available
- [ ] Scraper worker enriches houses with geo data in background
- [ ] In-memory cache prevents duplicate API calls for nearby properties
- [ ] Semaphore limits concurrent geo API calls to 10
- [ ] Pre-enriched listings skip live API calls in the scoring endpoint
</verification>

<success_criteria>
- School proximity data fetched from Quebec WFS endpoint
- Flood zone detection works via CEHQ ESRI REST API
- Park/playground count computed from Montreal open data + OSM fallback
- Geo data integrated into family scoring (school_proximity_pts, parks_pts, flood_zone flag)
- Background enrichment runs for HOUSE listings after scrape cycle
- All external API calls are fault-tolerant with timeouts and graceful fallbacks
- No impact on investment scoring or non-HOUSE property types
</success_criteria>

<output>
After completion, create `.planning/phases/09-family-homes/09-03-SUMMARY.md`
</output>
